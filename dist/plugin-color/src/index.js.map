{"version":3,"sources":["../../../packages/plugin-color/src/index.js"],"names":["mix","clr","clr2","p","r","g","b","colorFn","actions","cb","Array","isArray","throwError","call","map","action","apply","params","toRgb","scanQuiet","bitmap","width","height","x","y","idx","data","colorModifier","i","amount","constructor","limit255","forEach","opacity","f","v","color","colour"],"mappings":";;;;;;;;;;;AAAA;;AACA;;AAAoE;AAEpE;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA,SAASA,GAAT,CAAaC,GAAb,EAAkBC,IAAlB,EAAgC;AAAA,MAARC,CAAQ,uEAAJ,EAAI;AAC9B,SAAO;AACLC,IAAAA,CAAC,EAAE,CAACF,IAAI,CAACE,CAAL,GAASH,GAAG,CAACG,CAAd,KAAoBD,CAAC,GAAG,GAAxB,IAA+BF,GAAG,CAACG,CADjC;AAELC,IAAAA,CAAC,EAAE,CAACH,IAAI,CAACG,CAAL,GAASJ,GAAG,CAACI,CAAd,KAAoBF,CAAC,GAAG,GAAxB,IAA+BF,GAAG,CAACI,CAFjC;AAGLC,IAAAA,CAAC,EAAE,CAACJ,IAAI,CAACI,CAAL,GAASL,GAAG,CAACK,CAAd,KAAoBH,CAAC,GAAG,GAAxB,IAA+BF,GAAG,CAACK;AAHjC,GAAP;AAKD;;AAED,SAASC,OAAT,CAAiBC,OAAjB,EAA0BC,EAA1B,EAA8B;AAAA;;AAC5B,MAAI,CAACD,OAAD,IAAY,CAACE,KAAK,CAACC,OAAN,CAAcH,OAAd,CAAjB,EAAyC;AACvC,WAAOI,kBAAWC,IAAX,CAAgB,IAAhB,EAAsB,0BAAtB,EAAkDJ,EAAlD,CAAP;AACD;;AAEDD,EAAAA,OAAO,GAAGA,OAAO,CAACM,GAAR,CAAY,UAAAC,MAAM,EAAI;AAC9B,QAAIA,MAAM,CAACC,KAAP,KAAiB,KAAjB,IAA0BD,MAAM,CAACC,KAAP,KAAiB,KAA/C,EAAsD;AACpDD,MAAAA,MAAM,CAACE,MAAP,CAAc,CAAd,IAAmB,2BAAUF,MAAM,CAACE,MAAP,CAAc,CAAd,CAAV,EAA4BC,KAA5B,EAAnB;AACD;;AAED,WAAOH,MAAP;AACD,GANS,CAAV;AAQA,OAAKI,SAAL,CAAe,CAAf,EAAkB,CAAlB,EAAqB,KAAKC,MAAL,CAAYC,KAAjC,EAAwC,KAAKD,MAAL,CAAYE,MAApD,EAA4D,UAACC,CAAD,EAAIC,CAAJ,EAAOC,GAAP,EAAe;AACzE,QAAIxB,GAAG,GAAG;AACRG,MAAAA,CAAC,EAAE,KAAI,CAACgB,MAAL,CAAYM,IAAZ,CAAiBD,GAAjB,CADK;AAERpB,MAAAA,CAAC,EAAE,KAAI,CAACe,MAAL,CAAYM,IAAZ,CAAiBD,GAAG,GAAG,CAAvB,CAFK;AAGRnB,MAAAA,CAAC,EAAE,KAAI,CAACc,MAAL,CAAYM,IAAZ,CAAiBD,GAAG,GAAG,CAAvB;AAHK,KAAV;;AAMA,QAAME,aAAa,GAAG,SAAhBA,aAAgB,CAACC,CAAD,EAAIC,MAAJ;AAAA,aACpB,KAAI,CAACC,WAAL,CAAiBC,QAAjB,CAA0B9B,GAAG,CAAC2B,CAAD,CAAH,GAASC,MAAnC,CADoB;AAAA,KAAtB;;AAGArB,IAAAA,OAAO,CAACwB,OAAR,CAAgB,UAAAjB,MAAM,EAAI;AACxB,UAAIA,MAAM,CAACC,KAAP,KAAiB,KAArB,EAA4B;AAC1Bf,QAAAA,GAAG,GAAGD,GAAG,CAACC,GAAD,EAAMc,MAAM,CAACE,MAAP,CAAc,CAAd,CAAN,EAAwBF,MAAM,CAACE,MAAP,CAAc,CAAd,CAAxB,CAAT;AACD,OAFD,MAEO,IAAIF,MAAM,CAACC,KAAP,KAAiB,MAArB,EAA6B;AAClCf,QAAAA,GAAG,GAAGD,GAAG,CAACC,GAAD,EAAM;AAAEG,UAAAA,CAAC,EAAE,GAAL;AAAUC,UAAAA,CAAC,EAAE,GAAb;AAAkBC,UAAAA,CAAC,EAAE;AAArB,SAAN,EAAkCS,MAAM,CAACE,MAAP,CAAc,CAAd,CAAlC,CAAT;AACD,OAFM,MAEA,IAAIF,MAAM,CAACC,KAAP,KAAiB,OAArB,EAA8B;AACnCf,QAAAA,GAAG,GAAGD,GAAG,CAACC,GAAD,EAAM;AAAEG,UAAAA,CAAC,EAAE,CAAL;AAAQC,UAAAA,CAAC,EAAE,CAAX;AAAcC,UAAAA,CAAC,EAAE;AAAjB,SAAN,EAA4BS,MAAM,CAACE,MAAP,CAAc,CAAd,CAA5B,CAAT;AACD,OAFM,MAEA,IAAIF,MAAM,CAACC,KAAP,KAAiB,KAArB,EAA4B;AACjCf,QAAAA,GAAG,GAAG;AACJG,UAAAA,CAAC,EAAEH,GAAG,CAACG,CAAJ,GAAQW,MAAM,CAACE,MAAP,CAAc,CAAd,EAAiBb,CADxB;AAEJC,UAAAA,CAAC,EAAEJ,GAAG,CAACI,CAAJ,GAAQU,MAAM,CAACE,MAAP,CAAc,CAAd,EAAiBZ,CAFxB;AAGJC,UAAAA,CAAC,EAAEL,GAAG,CAACK,CAAJ,GAAQS,MAAM,CAACE,MAAP,CAAc,CAAd,EAAiBX;AAHxB,SAAN;AAKD,OANM,MAMA,IAAIS,MAAM,CAACC,KAAP,KAAiB,KAArB,EAA4B;AACjCf,QAAAA,GAAG,CAACG,CAAJ,GAAQuB,aAAa,CAAC,GAAD,EAAMZ,MAAM,CAACE,MAAP,CAAc,CAAd,CAAN,CAArB;AACD,OAFM,MAEA,IAAIF,MAAM,CAACC,KAAP,KAAiB,OAArB,EAA8B;AACnCf,QAAAA,GAAG,CAACI,CAAJ,GAAQsB,aAAa,CAAC,GAAD,EAAMZ,MAAM,CAACE,MAAP,CAAc,CAAd,CAAN,CAArB;AACD,OAFM,MAEA,IAAIF,MAAM,CAACC,KAAP,KAAiB,MAArB,EAA6B;AAClCf,QAAAA,GAAG,CAACK,CAAJ,GAAQqB,aAAa,CAAC,GAAD,EAAMZ,MAAM,CAACE,MAAP,CAAc,CAAd,CAAN,CAArB;AACD,OAFM,MAEA;AAAA;;AACL,YAAIF,MAAM,CAACC,KAAP,KAAiB,KAArB,EAA4B;AAC1BD,UAAAA,MAAM,CAACC,KAAP,GAAe,MAAf;AACD;;AAEDf,QAAAA,GAAG,GAAG,2BAAUA,GAAV,CAAN;;AAEA,YAAI,CAACA,GAAG,CAACc,MAAM,CAACC,KAAR,CAAR,EAAwB;AACtB,iBAAOJ,kBAAWC,IAAX,CACL,KADK,EAEL,YAAYE,MAAM,CAACC,KAAnB,GAA2B,gBAFtB,EAGLP,EAHK,CAAP;AAKD;;AAEDR,QAAAA,GAAG,GAAG,QAAAA,GAAG,EAACc,MAAM,CAACC,KAAR,CAAH,iDAAqBD,MAAM,CAACE,MAA5B,GAAoCC,KAApC,EAAN;AACD;AACF,KApCD;AAsCA,IAAA,KAAI,CAACE,MAAL,CAAYM,IAAZ,CAAiBD,GAAjB,IAAwBxB,GAAG,CAACG,CAA5B;AACA,IAAA,KAAI,CAACgB,MAAL,CAAYM,IAAZ,CAAiBD,GAAG,GAAG,CAAvB,IAA4BxB,GAAG,CAACI,CAAhC;AACA,IAAA,KAAI,CAACe,MAAL,CAAYM,IAAZ,CAAiBD,GAAG,GAAG,CAAvB,IAA4BxB,GAAG,CAACK,CAAhC;AACD,GAnDD;;AAqDA,MAAI,0BAAcG,EAAd,CAAJ,EAAuB;AACrBA,IAAAA,EAAE,CAACI,IAAH,CAAQ,IAAR,EAAc,IAAd,EAAoB,IAApB;AACD;;AAED,SAAO,IAAP;AACD;;eAEc;AAAA,SAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACEoB,IAAAA,OA/IoB,mBA+IZC,CA/IY,EA+ITzB,EA/IS,EA+IL;AACb,UAAI,OAAOyB,CAAP,KAAa,QAAjB,EACE,OAAOtB,kBAAWC,IAAX,CAAgB,IAAhB,EAAsB,oBAAtB,EAA4CJ,EAA5C,CAAP;AACF,UAAIyB,CAAC,GAAG,CAAJ,IAASA,CAAC,GAAG,CAAjB,EACE,OAAOtB,kBAAWC,IAAX,CAAgB,IAAhB,EAAsB,gCAAtB,EAAwDJ,EAAxD,CAAP;AAEF,WAAKU,SAAL,CAAe,CAAf,EAAkB,CAAlB,EAAqB,KAAKC,MAAL,CAAYC,KAAjC,EAAwC,KAAKD,MAAL,CAAYE,MAApD,EAA4D,UAC1DC,CAD0D,EAE1DC,CAF0D,EAG1DC,GAH0D,EAI1D;AACA,YAAMU,CAAC,GAAG,KAAKf,MAAL,CAAYM,IAAZ,CAAiBD,GAAG,GAAG,CAAvB,IAA4BS,CAAtC;AACA,aAAKd,MAAL,CAAYM,IAAZ,CAAiBD,GAAG,GAAG,CAAvB,IAA4BU,CAA5B;AACD,OAPD;;AASA,UAAI,0BAAc1B,EAAd,CAAJ,EAAuB;AACrBA,QAAAA,EAAE,CAACI,IAAH,CAAQ,IAAR,EAAc,IAAd,EAAoB,IAApB;AACD;;AAED,aAAO,IAAP;AACD,KAnKmB;AAqKpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACEuB,IAAAA,KAAK,EAAE7B,OAtea;AAuepB8B,IAAAA,MAAM,EAAE9B;AAveY,GAAP;AAAA,C","sourcesContent":["import tinyColor from 'tinycolor2';\nimport { throwError, isNodePattern } from \"../../utils/src/index.js\"//'@PJW/utils';\n\n// function applyKernel(im, kernel, x, y) {\n//   const value = [0, 0, 0];\n//   const size = (kernel.length - 1) / 2;\n\n//   for (let kx = 0; kx < kernel.length; kx += 1) {\n//     for (let ky = 0; ky < kernel[kx].length; ky += 1) {\n//       const idx = im.getPixelIndex(x + kx - size, y + ky - size);\n\n//       value[0] += im.bitmap.data[idx] * kernel[kx][ky];\n//       value[1] += im.bitmap.data[idx + 1] * kernel[kx][ky];\n//       value[2] += im.bitmap.data[idx + 2] * kernel[kx][ky];\n//     }\n//   }\n\n//   return value;\n// }\n\n//const isDef = v => typeof v !== 'undefined' && v !== null;\n\n// function greyscale(cb) {\n//   this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(\n//     x,\n//     y,\n//     idx\n//   ) {\n//     const grey = parseInt(\n//       0.2126 * this.bitmap.data[idx] +\n//         0.7152 * this.bitmap.data[idx + 1] +\n//         0.0722 * this.bitmap.data[idx + 2],\n//       10\n//     );\n\n//     this.bitmap.data[idx] = grey;\n//     this.bitmap.data[idx + 1] = grey;\n//     this.bitmap.data[idx + 2] = grey;\n//   });\n\n//   if (isNodePattern(cb)) {\n//     cb.call(this, null, this);\n//   }\n\n//   return this;\n// }\n\nfunction mix(clr, clr2, p = 50) {\n  return {\n    r: (clr2.r - clr.r) * (p / 100) + clr.r,\n    g: (clr2.g - clr.g) * (p / 100) + clr.g,\n    b: (clr2.b - clr.b) * (p / 100) + clr.b\n  };\n}\n\nfunction colorFn(actions, cb) {\n  if (!actions || !Array.isArray(actions)) {\n    return throwError.call(this, 'actions must be an array', cb);\n  }\n\n  actions = actions.map(action => {\n    if (action.apply === 'xor' || action.apply === 'mix') {\n      action.params[0] = tinyColor(action.params[0]).toRgb();\n    }\n\n    return action;\n  });\n\n  this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (x, y, idx) => {\n    let clr = {\n      r: this.bitmap.data[idx],\n      g: this.bitmap.data[idx + 1],\n      b: this.bitmap.data[idx + 2]\n    };\n\n    const colorModifier = (i, amount) =>\n      this.constructor.limit255(clr[i] + amount);\n\n    actions.forEach(action => {\n      if (action.apply === 'mix') {\n        clr = mix(clr, action.params[0], action.params[1]);\n      } else if (action.apply === 'tint') {\n        clr = mix(clr, { r: 255, g: 255, b: 255 }, action.params[0]);\n      } else if (action.apply === 'shade') {\n        clr = mix(clr, { r: 0, g: 0, b: 0 }, action.params[0]);\n      } else if (action.apply === 'xor') {\n        clr = {\n          r: clr.r ^ action.params[0].r,\n          g: clr.g ^ action.params[0].g,\n          b: clr.b ^ action.params[0].b\n        };\n      } else if (action.apply === 'red') {\n        clr.r = colorModifier('r', action.params[0]);\n      } else if (action.apply === 'green') {\n        clr.g = colorModifier('g', action.params[0]);\n      } else if (action.apply === 'blue') {\n        clr.b = colorModifier('b', action.params[0]);\n      } else {\n        if (action.apply === 'hue') {\n          action.apply = 'spin';\n        }\n\n        clr = tinyColor(clr);\n\n        if (!clr[action.apply]) {\n          return throwError.call(\n            this,\n            'action ' + action.apply + ' not supported',\n            cb\n          );\n        }\n\n        clr = clr[action.apply](...action.params).toRgb();\n      }\n    });\n\n    this.bitmap.data[idx] = clr.r;\n    this.bitmap.data[idx + 1] = clr.g;\n    this.bitmap.data[idx + 2] = clr.b;\n  });\n\n  if (isNodePattern(cb)) {\n    cb.call(this, null, this);\n  }\n\n  return this;\n}\n\nexport default () => ({\n  // /**\n  //  * Adjusts the brightness of the image\n  //  * @param {number} val the amount to adjust the brightness, a number between -1 and +1\n  //  * @param {function(Error, PJW)} cb (optional) a callback for when complete\n  //  * @returns {PJW }this for chaining of methods\n  //  */\n  // brightness(val, cb) {\n  //   if (typeof val !== 'number') {\n  //     return throwError.call(this, 'val must be numbers', cb);\n  //   }\n\n  //   if (val < -1 || val > +1) {\n  //     return throwError.call(\n  //       this,\n  //       'val must be a number between -1 and +1',\n  //       cb\n  //     );\n  //   }\n\n  //   this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(\n  //     x,\n  //     y,\n  //     idx\n  //   ) {\n  //     if (val < 0.0) {\n  //       this.bitmap.data[idx] = this.bitmap.data[idx] * (1 + val);\n  //       this.bitmap.data[idx + 1] = this.bitmap.data[idx + 1] * (1 + val);\n  //       this.bitmap.data[idx + 2] = this.bitmap.data[idx + 2] * (1 + val);\n  //     } else {\n  //       this.bitmap.data[idx] =\n  //         this.bitmap.data[idx] + (255 - this.bitmap.data[idx]) * val;\n  //       this.bitmap.data[idx + 1] =\n  //         this.bitmap.data[idx + 1] + (255 - this.bitmap.data[idx + 1]) * val;\n  //       this.bitmap.data[idx + 2] =\n  //         this.bitmap.data[idx + 2] + (255 - this.bitmap.data[idx + 2]) * val;\n  //     }\n  //   });\n\n  //   if (isNodePattern(cb)) {\n  //     cb.call(this, null, this);\n  //   }\n\n  //   return this;\n  // },\n\n  // /**\n  //  * Adjusts the contrast of the image\n  //  * @param {number} val the amount to adjust the contrast, a number between -1 and +1\n  //  * @param {function(Error, PJW)} cb (optional) a callback for when complete\n  //  * @returns {PJW }this for chaining of methods\n  //  */\n  // contrast(val, cb) {\n  //   if (typeof val !== 'number') {\n  //     return throwError.call(this, 'val must be numbers', cb);\n  //   }\n\n  //   if (val < -1 || val > +1) {\n  //     return throwError.call(\n  //       this,\n  //       'val must be a number between -1 and +1',\n  //       cb\n  //     );\n  //   }\n\n  //   const factor = (val + 1) / (1 - val);\n\n  //   function adjust(value) {\n  //     value = Math.floor(factor * (value - 127) + 127);\n\n  //     return value < 0 ? 0 : value > 255 ? 255 : value;\n  //   }\n\n  //   this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(\n  //     x,\n  //     y,\n  //     idx\n  //   ) {\n  //     this.bitmap.data[idx] = adjust(this.bitmap.data[idx]);\n  //     this.bitmap.data[idx + 1] = adjust(this.bitmap.data[idx + 1]);\n  //     this.bitmap.data[idx + 2] = adjust(this.bitmap.data[idx + 2]);\n  //   });\n\n  //   if (isNodePattern(cb)) {\n  //     cb.call(this, null, this);\n  //   }\n\n  //   return this;\n  // },\n\n  // /**\n  //  * Apply a posterize effect\n  //  * @param {number} n the amount to adjust the contrast, minimum threshold is two\n  //  * @param {function(Error, PJW)} cb (optional) a callback for when complete\n  //  * @returns {PJW }this for chaining of methods\n  //  */\n  // posterize(n, cb) {\n  //   if (typeof n !== 'number') {\n  //     return throwError.call(this, 'n must be numbers', cb);\n  //   }\n\n  //   if (n < 2) {\n  //     n = 2;\n  //   } // minimum of 2 levels\n\n  //   this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(\n  //     x,\n  //     y,\n  //     idx\n  //   ) {\n  //     this.bitmap.data[idx] =\n  //       (Math.floor((this.bitmap.data[idx] / 255) * (n - 1)) / (n - 1)) * 255;\n  //     this.bitmap.data[idx + 1] =\n  //       (Math.floor((this.bitmap.data[idx + 1] / 255) * (n - 1)) / (n - 1)) *\n  //       255;\n  //     this.bitmap.data[idx + 2] =\n  //       (Math.floor((this.bitmap.data[idx + 2] / 255) * (n - 1)) / (n - 1)) *\n  //       255;\n  //   });\n\n  //   if (isNodePattern(cb)) {\n  //     cb.call(this, null, this);\n  //   }\n\n  //   return this;\n  // },\n\n  // /**\n  //  * Removes colour from the image using ITU Rec 709 luminance values\n  //  * @param {function(Error, PJW)} cb (optional) a callback for when complete\n  //  * @returns {PJW }this for chaining of methods\n  //  */\n  // greyscale,\n\n  // // Alias of greyscale for our American friends\n  // grayscale: greyscale,\n\n  /**\n   * Multiplies the opacity of each pixel by a factor between 0 and 1\n   * @param {number} f A number, the factor by which to multiply the opacity of each pixel\n   * @param {function(Error, PJW)} cb (optional) a callback for when complete\n   * @returns {PJW }this for chaining of methods\n   */\n  opacity(f, cb) {\n    if (typeof f !== 'number')\n      return throwError.call(this, 'f must be a number', cb);\n    if (f < 0 || f > 1)\n      return throwError.call(this, 'f must be a number from 0 to 1', cb);\n\n    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(\n      x,\n      y,\n      idx\n    ) {\n      const v = this.bitmap.data[idx + 3] * f;\n      this.bitmap.data[idx + 3] = v;\n    });\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  },\n\n  // /**\n  //  * Applies a sepia tone to the image\n  //  * @param {function(Error, PJW)} cb (optional) a callback for when complete\n  //  * @returns {PJW }this for chaining of methods\n  //  */\n  // sepia(cb) {\n  //   this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(\n  //     x,\n  //     y,\n  //     idx\n  //   ) {\n  //     let red = this.bitmap.data[idx];\n  //     let green = this.bitmap.data[idx + 1];\n  //     let blue = this.bitmap.data[idx + 2];\n\n  //     red = red * 0.393 + green * 0.769 + blue * 0.189;\n  //     green = red * 0.349 + green * 0.686 + blue * 0.168;\n  //     blue = red * 0.272 + green * 0.534 + blue * 0.131;\n\n  //     this.bitmap.data[idx] = red < 255 ? red : 255;\n  //     this.bitmap.data[idx + 1] = green < 255 ? green : 255;\n  //     this.bitmap.data[idx + 2] = blue < 255 ? blue : 255;\n  //   });\n\n  //   if (isNodePattern(cb)) {\n  //     cb.call(this, null, this);\n  //   }\n\n  //   return this;\n  // },\n\n  // /**\n  //  * Fades each pixel by a factor between 0 and 1\n  //  * @param {number} f A number from 0 to 1. 0 will haven no effect. 1 will turn the image completely transparent.\n  //  * @param {function(Error, PJW)} cb (optional) a callback for when complete\n  //  * @returns {PJW }this for chaining of methods\n  //  */\n  // fade(f, cb) {\n  //   if (typeof f !== 'number') {\n  //     return throwError.call(this, 'f must be a number', cb);\n  //   }\n\n  //   if (f < 0 || f > 1) {\n  //     return throwError.call(this, 'f must be a number from 0 to 1', cb);\n  //   }\n\n  //   // this method is an alternative to opacity (which may be deprecated)\n  //   this.opacity(1 - f);\n\n  //   if (isNodePattern(cb)) {\n  //     cb.call(this, null, this);\n  //   }\n\n  //   return this;\n  // },\n\n  // /**\n  //  * Adds each element of the image to its local neighbors, weighted by the kernel\n  //  * @param {array} kernel a matrix to weight the neighbors sum\n  //  * @param {string} edgeHandling (optional) define how to sum pixels from outside the border\n  //  * @param {function(Error, PJW)} cb (optional) a callback for when complete\n  //  * @returns {PJW }this for chaining of methods\n  //  */\n  // convolution(kernel, edgeHandling, cb) {\n  //   if (typeof edgeHandling === 'function' && typeof cb === 'undefined') {\n  //     cb = edgeHandling;\n  //     edgeHandling = null;\n  //   }\n\n  //   if (!edgeHandling) {\n  //     edgeHandling = this.constructor.EDGE_EXTEND;\n  //   }\n\n  //   const newData = Buffer.from(this.bitmap.data);\n  //   const kRows = kernel.length;\n  //   const kCols = kernel[0].length;\n  //   const rowEnd = Math.floor(kRows / 2);\n  //   const colEnd = Math.floor(kCols / 2);\n  //   const rowIni = -rowEnd;\n  //   const colIni = -colEnd;\n\n  //   let weight;\n  //   let rSum;\n  //   let gSum;\n  //   let bSum;\n  //   let ri;\n  //   let gi;\n  //   let bi;\n  //   let xi;\n  //   let yi;\n  //   let idxi;\n\n  //   this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(\n  //     x,\n  //     y,\n  //     idx\n  //   ) {\n  //     bSum = 0;\n  //     gSum = 0;\n  //     rSum = 0;\n\n  //     for (let row = rowIni; row <= rowEnd; row++) {\n  //       for (let col = colIni; col <= colEnd; col++) {\n  //         xi = x + col;\n  //         yi = y + row;\n  //         weight = kernel[row + rowEnd][col + colEnd];\n  //         idxi = this.getPixelIndex(xi, yi, edgeHandling);\n\n  //         if (idxi === -1) {\n  //           bi = 0;\n  //           gi = 0;\n  //           ri = 0;\n  //         } else {\n  //           ri = this.bitmap.data[idxi + 0];\n  //           gi = this.bitmap.data[idxi + 1];\n  //           bi = this.bitmap.data[idxi + 2];\n  //         }\n\n  //         rSum += weight * ri;\n  //         gSum += weight * gi;\n  //         bSum += weight * bi;\n  //       }\n  //     }\n\n  //     if (rSum < 0) {\n  //       rSum = 0;\n  //     }\n\n  //     if (gSum < 0) {\n  //       gSum = 0;\n  //     }\n\n  //     if (bSum < 0) {\n  //       bSum = 0;\n  //     }\n\n  //     if (rSum > 255) {\n  //       rSum = 255;\n  //     }\n\n  //     if (gSum > 255) {\n  //       gSum = 255;\n  //     }\n\n  //     if (bSum > 255) {\n  //       bSum = 255;\n  //     }\n\n  //     newData[idx + 0] = rSum;\n  //     newData[idx + 1] = gSum;\n  //     newData[idx + 2] = bSum;\n  //   });\n\n  //   this.bitmap.data = newData;\n\n  //   if (isNodePattern(cb)) {\n  //     cb.call(this, null, this);\n  //   }\n\n  //   return this;\n  // },\n\n  // /**\n  //  * Set the alpha channel on every pixel to fully opaque\n  //  * @param {function(Error, PJW)} cb (optional) a callback for when complete\n  //  * @returns {PJW }this for chaining of methods\n  //  */\n  // opaque(cb) {\n  //   this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(\n  //     x,\n  //     y,\n  //     idx\n  //   ) {\n  //     this.bitmap.data[idx + 3] = 255;\n  //   });\n\n  //   if (isNodePattern(cb)) {\n  //     cb.call(this, null, this);\n  //   }\n\n  //   return this;\n  // },\n\n  // /**\n  //  * Pixelates the image or a region\n  //  * @param {number} size the size of the pixels\n  //  * @param {number} x (optional) the x position of the region to pixelate\n  //  * @param {number} y (optional) the y position of the region to pixelate\n  //  * @param {number} w (optional) the width of the region to pixelate\n  //  * @param {number} h (optional) the height of the region to pixelate\n  //  * @param {function(Error, PJW)} cb (optional) a callback for when complete\n  //  * @returns {PJW }this for chaining of methods\n  //  */\n  // pixelate(size, x, y, w, h, cb) {\n  //   if (typeof x === 'function') {\n  //     cb = x;\n  //     h = null;\n  //     w = null;\n  //     y = null;\n  //     x = null;\n  //   } else {\n  //     if (typeof size !== 'number') {\n  //       return throwError.call(this, 'size must be a number', cb);\n  //     }\n\n  //     if (isDef(x) && typeof x !== 'number') {\n  //       return throwError.call(this, 'x must be a number', cb);\n  //     }\n\n  //     if (isDef(y) && typeof y !== 'number') {\n  //       return throwError.call(this, 'y must be a number', cb);\n  //     }\n\n  //     if (isDef(w) && typeof w !== 'number') {\n  //       return throwError.call(this, 'w must be a number', cb);\n  //     }\n\n  //     if (isDef(h) && typeof h !== 'number') {\n  //       return throwError.call(this, 'h must be a number', cb);\n  //     }\n  //   }\n\n  //   const kernel = [\n  //     [1 / 16, 2 / 16, 1 / 16],\n  //     [2 / 16, 4 / 16, 2 / 16],\n  //     [1 / 16, 2 / 16, 1 / 16]\n  //   ];\n\n  //   x = x || 0;\n  //   y = y || 0;\n  //   w = isDef(w) ? w : this.bitmap.width - x;\n  //   h = isDef(h) ? h : this.bitmap.height - y;\n\n  //   const source = this.cloneQuiet();\n\n  //   this.scanQuiet(x, y, w, h, function(xx, yx, idx) {\n  //     xx = size * Math.floor(xx / size);\n  //     yx = size * Math.floor(yx / size);\n\n  //     const value = applyKernel(source, kernel, xx, yx);\n\n  //     this.bitmap.data[idx] = value[0];\n  //     this.bitmap.data[idx + 1] = value[1];\n  //     this.bitmap.data[idx + 2] = value[2];\n  //   });\n\n  //   if (isNodePattern(cb)) {\n  //     cb.call(this, null, this);\n  //   }\n\n  //   return this;\n  // },\n\n  // /**\n  //  * Applies a convolution kernel to the image or a region\n  //  * @param {array} kernel the convolution kernel\n  //  * @param {number} x (optional) the x position of the region to apply convolution to\n  //  * @param {number} y (optional) the y position of the region to apply convolution to\n  //  * @param {number} w (optional) the width of the region to apply convolution to\n  //  * @param {number} h (optional) the height of the region to apply convolution to\n  //  * @param {function(Error, PJW)} cb (optional) a callback for when complete\n  //  * @returns {PJW }this for chaining of methods\n  //  */\n  // convolute(kernel, x, y, w, h, cb) {\n  //   if (!Array.isArray(kernel))\n  //     return throwError.call(this, 'the kernel must be an array', cb);\n\n  //   if (typeof x === 'function') {\n  //     cb = x;\n  //     x = null;\n  //     y = null;\n  //     w = null;\n  //     h = null;\n  //   } else {\n  //     if (isDef(x) && typeof x !== 'number') {\n  //       return throwError.call(this, 'x must be a number', cb);\n  //     }\n\n  //     if (isDef(y) && typeof y !== 'number') {\n  //       return throwError.call(this, 'y must be a number', cb);\n  //     }\n\n  //     if (isDef(w) && typeof w !== 'number') {\n  //       return throwError.call(this, 'w must be a number', cb);\n  //     }\n\n  //     if (isDef(h) && typeof h !== 'number') {\n  //       return throwError.call(this, 'h must be a number', cb);\n  //     }\n  //   }\n\n  //   const ksize = (kernel.length - 1) / 2;\n\n  //   x = isDef(x) ? x : ksize;\n  //   y = isDef(y) ? y : ksize;\n  //   w = isDef(w) ? w : this.bitmap.width - x;\n  //   h = isDef(h) ? h : this.bitmap.height - y;\n\n  //   const source = this.cloneQuiet();\n\n  //   this.scanQuiet(x, y, w, h, function(xx, yx, idx) {\n  //     const value = applyKernel(source, kernel, xx, yx);\n\n  //     this.bitmap.data[idx] = this.constructor.limit255(value[0]);\n  //     this.bitmap.data[idx + 1] = this.constructor.limit255(value[1]);\n  //     this.bitmap.data[idx + 2] = this.constructor.limit255(value[2]);\n  //   });\n\n  //   if (isNodePattern(cb)) {\n  //     cb.call(this, null, this);\n  //   }\n\n  //   return this;\n  // },\n\n  /**\n   * Apply multiple color modification rules\n   * @param {array} actions list of color modification rules, in following format: { apply: '<rule-name>', params: [ <rule-parameters> ]  }\n   * @param {function(Error, PJW)} cb (optional) a callback for when complete\n   * @returns {PJW }this for chaining of methods\n   */\n  color: colorFn,\n  colour: colorFn\n});\n"],"file":"index.js"}